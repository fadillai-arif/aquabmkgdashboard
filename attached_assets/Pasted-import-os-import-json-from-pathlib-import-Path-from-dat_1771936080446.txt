import os
import json
from pathlib import Path
from datetime import datetime
from flask import Flask, render_template, send_from_directory, jsonify
from dotenv import load_dotenv

load_dotenv()

BASE_DIR = Path(os.environ.get("EWS_BASE_DIR", Path(__file__).resolve().parent))
DATA_DIR = BASE_DIR / "data"
STATIC_DIR = BASE_DIR / "static"
MAPS_DIR = STATIC_DIR / "maps"

DATA_DIR.mkdir(parents=True, exist_ok=True)
MAPS_DIR.mkdir(parents=True, exist_ok=True)

LOG_FILE = DATA_DIR / "weather_log.jsonl"
STATE_FILE = DATA_DIR / "alert_state.json"

app = Flask(__name__, static_folder=str(STATIC_DIR), template_folder=str(BASE_DIR / "templates"))

# --- Helpers ---
def parse_jsonl(path: Path, max_lines: int = 200):
    """Read last up to max_lines entries from JSONL."""
    if not path.exists():
        return []
    lines = []
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            lines.append(line)
    # Use last max_lines
    lines = lines[-max_lines:]
    entries = []
    for line in lines:
        try:
            entries.append(json.loads(line))
        except Exception:
            continue
    return entries

def read_latest_log():
    entries = parse_jsonl(LOG_FILE, max_lines=200)
    return entries[-1] if entries else None

def read_state():
    if STATE_FILE.exists():
        try:
            with STATE_FILE.open("r", encoding="utf-8") as f:
                return json.load(f)
        except Exception:
            return {}
    return {}

def level_from_count(cnt: int):
    if cnt >= 10:
        return "BAHAYA"
    if cnt >= 5:
        return "SIAGA"
    if cnt >= 1:
        return "WASPADA"
    return ""

def color_for_level(level: str):
    # UI color chips
    if level == "BAHAYA":
        return "#e74c3c"  # merah
    if level == "SIAGA":
        return "#e67e22"  # oranye
    if level == "WASPADA":
        return "#f1c40f"  # kuning
    return "#95a5a6"      # abu

@app.route("/")
def index():
    latest = read_latest_log()
    state = read_state()

    # Resolve image path
    latest_map_rel = "maps/latest.jpg"
    latest_map_abs = MAPS_DIR / "latest.jpg"
    if not latest_map_abs.exists() and latest and latest.get("image_path"):
        # fallback ke path dari log
        p = BASE_DIR / latest["image_path"]
        if p.exists():
            latest_map_rel = str(Path(latest["image_path"]).relative_to(STATIC_DIR))

    # Build current alerts
    current_time = None
    current_alerts = []
    if latest:
        current_time = latest.get("time_wib")
        for loc in latest.get("locations", []):
            # If log already included level, use it; else derive from count
            level = loc.get("level") or level_from_count(int(loc.get("count", 0)))
            current_alerts.append({
                "location": loc.get("location"),
                "count": int(loc.get("count", 0)),
                "level": level,
                "dominant_color": loc.get("dominant_color"),
                "weather_warning": loc.get("weather_warning", ""),
                "rgb": loc.get("rgb", [0,0,0]),
                "pixel": loc.get("pixel", [0,0]),
                "chip_color": color_for_level(level)
            })
    else:
        # fallback minimal bila log belum ada: tampilkan dari state.json saja (tanpa detail warna)
        for loc, cnt in sorted(state.items()):
            if int(cnt) > 0:
                level = level_from_count(int(cnt))
                current_alerts.append({
                    "location": loc,
                    "count": int(cnt),
                    "level": level,
                    "dominant_color": None,
                    "weather_warning": "Hujan Lebat - Sangat Lebat" if level else "",
                    "rgb": None,
                    "pixel": None,
                    "chip_color": color_for_level(level)
                })

    # Recent runs (for history list)
    recent_entries = parse_jsonl(LOG_FILE, max_lines=50)  # ringkas untuk UI

    return render_template(
        "index.html",
        title="AQUA Site Early Warning System Dashboard",
        latest_map_rel=latest_map_rel,
        current_time=current_time,
        current_alerts=current_alerts,
        recent_entries=recent_entries
    )

# --- Simple APIs for automation/monitoring ---
@app.route("/api/alerts")
def api_alerts():
    latest = read_latest_log()
    if not latest:
        return jsonify({"ok": True, "data": [], "note": "no logs yet"}), 200
    return jsonify({"ok": True, "data": latest}), 200

@app.route("/api/logs")
def api_logs():
    entries = parse_jsonl(LOG_FILE, max_lines=200)
    return jsonify({"ok": True, "data": entries}), 200

@app.route("/healthz")
def healthz():
    return "ok", 200

# Static maps passthrough if needed (PythonAnywhere will map /static anyway)
@app.route("/maps/<path:filename>")
def maps(filename):
    return send_from_directory(str(MAPS_DIR), filename)

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", "5000")), debug=False)